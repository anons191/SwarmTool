#!/usr/bin/env bash
# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║  swarmtool -- Multi-agent orchestration for Claude Code                  ║
# ║  Dumb workers, smart orchestration.                                      ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
set -euo pipefail

# ── Resolve Installation Directory ──────────────────────────────────────────
# Follow symlinks to find the real script location
SWARMTOOL_DIR="$(cd "$(dirname "$(readlink -f "$0" 2>/dev/null || echo "$0")")" && pwd)"

# ── Source Libraries ────────────────────────────────────────────────────────
source "${SWARMTOOL_DIR}/lib/core.sh"
source "${SWARMTOOL_DIR}/lib/config.sh"
source "${SWARMTOOL_DIR}/lib/providers.sh"
source "${SWARMTOOL_DIR}/lib/state.sh"
source "${SWARMTOOL_DIR}/lib/taskspec.sh"
source "${SWARMTOOL_DIR}/lib/scale.sh"
source "${SWARMTOOL_DIR}/lib/cleanup.sh"

# Source optional modules (loaded as they are built)
[[ -f "${SWARMTOOL_DIR}/lib/prompt.sh" ]]       && source "${SWARMTOOL_DIR}/lib/prompt.sh"
[[ -f "${SWARMTOOL_DIR}/lib/planner.sh" ]]      && source "${SWARMTOOL_DIR}/lib/planner.sh"
[[ -f "${SWARMTOOL_DIR}/lib/worker.sh" ]]       && source "${SWARMTOOL_DIR}/lib/worker.sh"
[[ -f "${SWARMTOOL_DIR}/lib/judge.sh" ]]        && source "${SWARMTOOL_DIR}/lib/judge.sh"
[[ -f "${SWARMTOOL_DIR}/lib/merge.sh" ]]        && source "${SWARMTOOL_DIR}/lib/merge.sh"
[[ -f "${SWARMTOOL_DIR}/lib/interactive.sh" ]]  && source "${SWARMTOOL_DIR}/lib/interactive.sh"
[[ -f "${SWARMTOOL_DIR}/lib/resume.sh" ]]       && source "${SWARMTOOL_DIR}/lib/resume.sh"
[[ -f "${SWARMTOOL_DIR}/lib/conventions.sh" ]]  && source "${SWARMTOOL_DIR}/lib/conventions.sh"
[[ -f "${SWARMTOOL_DIR}/lib/fix.sh" ]]          && source "${SWARMTOOL_DIR}/lib/fix.sh"
[[ -f "${SWARMTOOL_DIR}/lib/interview.sh" ]]    && source "${SWARMTOOL_DIR}/lib/interview.sh"
[[ -f "${SWARMTOOL_DIR}/lib/display.sh" ]]      && source "${SWARMTOOL_DIR}/lib/display.sh"
[[ -f "${SWARMTOOL_DIR}/lib/retry.sh" ]]        && source "${SWARMTOOL_DIR}/lib/retry.sh"

# ── CLI Argument Parsing ────────────────────────────────────────────────────
GOAL=""
RESUME_RUN_ID=""
DRY_RUN=false
VERBOSE=false
SHOW_CONFIG=false
SHOW_PROVIDERS=false
LIST_RUNS=false
FIX_MODE=false
FIX_DIR="."
INTERVIEW_MODE=""  # empty = prompt user, "true" = force interview, "false" = skip

usage() {
    cat <<EOF
${BOLD}swarmtool${NC} v${SWARMTOOL_VERSION} -- Multi-agent orchestration for Claude Code

${BOLD}USAGE${NC}
    swarmtool [OPTIONS] [GOAL]

${BOLD}DESCRIPTION${NC}
    Orchestrates multiple Claude Code agents to work on a goal in parallel.
    Uses a two-tier architecture: a Planner decomposes the goal into isolated
    tasks, Workers execute them in git worktrees, and a Judge evaluates results.

${BOLD}OPTIONS${NC}
    --goal <text>         Set the goal (alternative to positional argument)
    --resume <run-id>     Resume an interrupted run
    --list                List all runs and their status
    --fix [dir]           Fix integration issues in merged code (default: current dir)
    --max-workers <n>     Set max concurrent workers (default: auto)

    ${BOLD}Provider Options${NC} (format: provider:model, e.g., "claude:opus", "ollama:qwen2")
    --planner <spec>      Provider:model for planner (default: claude:opus)
    --worker <spec>       Provider:model for workers (default: claude:sonnet)
    --judge <spec>        Provider:model for judge (default: claude:opus)
    --fixer <spec>        Provider:model for fixer (default: claude:opus)
    --merger <spec>       Provider:model for merger (default: claude:opus)

    ${BOLD}Legacy Options${NC} (Claude-only, for backwards compatibility)
    --planner-model <m>   Model for planner (e.g., opus)
    --worker-model <m>    Model for workers (e.g., sonnet)
    --judge-model <m>     Model for judge (e.g., opus)

    ${BOLD}Interview Options${NC}
    --interview           Force interview phase to gather requirements
    --no-interview        Skip interview prompt, go straight to planning

    --budget <usd>        Total budget cap in USD (default: 20.00)
    --dry-run             Show plan without executing
    --auto-approve, -y    Auto-approve all steps after plan approval
    --verbose             Show detailed output including resource detection
    --config              Show current configuration and exit
    --providers           List available LLM providers and their status
    --help                Show this help message

${BOLD}EXAMPLES${NC}
    swarmtool "Add user authentication with JWT"
    swarmtool --interview "Add authentication"   # Interview first, then plan
    swarmtool --goal "Refactor the database layer" --max-workers 3
    swarmtool --worker ollama:qwen2 --judge openai:gpt-4o "Build a todo app"
    swarmtool --resume abc12345
    swarmtool --fix                    # Fix integration issues in current directory
    swarmtool --list
    swarmtool --providers              # List available LLM providers

${BOLD}PROVIDERS${NC}
    claude     Claude via Claude Code CLI (default)
    openai     OpenAI API (requires OPENAI_API_KEY)
    openrouter OpenRouter API (requires OPENROUTER_API_KEY)
    ollama     Local Ollama server (requires Ollama running)
    lmstudio   Local LM Studio server (requires LM Studio running)

${BOLD}ARCHITECTURE${NC}
    Planner (claude:opus)  -->  Creates isolated task specs
    Workers (claude:sonnet) -->  Execute in git worktrees, no coordination
    Judge (claude:opus)  -->  Automated checks + AI evaluation
    Merge                -->  Auto-merge + conflict resolution

${BOLD}CONFIGURATION${NC}
    Config precedence: defaults.conf < .swarmtool/config < env vars < CLI flags
    See defaults.conf for all configurable options.

EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h)
            usage
            exit 0
            ;;
        --goal)
            GOAL="$2"
            shift 2
            ;;
        --resume)
            RESUME_RUN_ID="$2"
            shift 2
            ;;
        --list)
            LIST_RUNS=true
            shift
            ;;
        --fix)
            FIX_MODE=true
            # Check if next arg is a directory (not a flag)
            if [[ "${2:-}" && ! "${2:-}" =~ ^- ]]; then
                FIX_DIR="$2"
                shift
            fi
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --auto-approve|-y)
            AUTO_APPROVE=true
            shift
            ;;
        --verbose|-v)
            VERBOSE=true
            shift
            ;;
        --config)
            SHOW_CONFIG=true
            shift
            ;;
        --providers)
            SHOW_PROVIDERS=true
            shift
            ;;
        --interview)
            INTERVIEW_MODE=true
            shift
            ;;
        --no-interview)
            INTERVIEW_MODE=false
            shift
            ;;
        --max-workers|--planner|--worker|--judge|--fixer|--merger|--planner-model|--worker-model|--judge-model|--budget|--state-dir)
            apply_cli_overrides "$1" "$2"
            shift 2
            ;;
        -*)
            die "Unknown option: $1. Use --help for usage."
            ;;
        *)
            # Positional argument = goal
            if [[ -z "$GOAL" ]]; then
                GOAL="$1"
            else
                die "Unexpected argument: $1. Goal already set."
            fi
            shift
            ;;
    esac
done

# ── Load Configuration ──────────────────────────────────────────────────────
load_config "$SWARMTOOL_DIR"

# ── Handle Simple Commands ──────────────────────────────────────────────────

if [[ "$SHOW_CONFIG" == "true" ]]; then
    dump_config
    exit 0
fi

if [[ "$SHOW_PROVIDERS" == "true" ]]; then
    list_providers
    exit 0
fi

if [[ "$LIST_RUNS" == "true" ]]; then
    list_runs
    exit 0
fi

# ── Fix Mode ───────────────────────────────────────────────────────────────
if [[ "$FIX_MODE" == "true" ]]; then
    if type run_fix_command &>/dev/null; then
        run_fix_command "$FIX_DIR"
        exit $?
    else
        die "Fix module not available."
    fi
fi

# ── Prerequisites ───────────────────────────────────────────────────────────
check_prerequisites

# ── Setup Signal Handlers ───────────────────────────────────────────────────
setup_signal_handlers

# ── Resume Mode ─────────────────────────────────────────────────────────────
if [[ -n "$RESUME_RUN_ID" ]]; then
    if type resume_run &>/dev/null; then
        resume_run "$RESUME_RUN_ID"
    else
        die "Resume module not yet available. Build Phase 7 first."
    fi
    exit $?
fi

# ── Interactive Mode ────────────────────────────────────────────────────────

# Show startup banner
if type show_banner &>/dev/null; then
    show_banner
else
    print_header "swarmtool v${SWARMTOOL_VERSION}"
fi

# Step 1: Capture goal
if [[ -z "$GOAL" ]]; then
    echo ""
    printf "${BOLD}What would you like to accomplish?${NC}\n"
    printf "> "
    read -r GOAL
    echo ""

    if [[ -z "$GOAL" ]]; then
        die "No goal provided. Exiting."
    fi
fi

echo "Goal: ${GOAL}"
echo ""

# Step 2: Initialize run
RUN_ID=$(generate_id)
RUN_DIR=$(init_run_dir "$RUN_ID" "$GOAL")
CURRENT_RUN_ID="$RUN_ID"
CURRENT_RUN_DIR="$RUN_DIR"

log "$RUN_ID" "INIT" "Run initialized: $GOAL"

# Generate conventions file for consistent worker output
if type generate_conventions_file &>/dev/null; then
    generate_conventions_file "$RUN_DIR" "."
    log "$RUN_ID" "INIT" "Generated conventions file"
fi

if [[ "$VERBOSE" == "true" ]]; then
    dump_config
    display_resources
fi

# Step 2b: Interview phase (optional)
if type run_interview_phase &>/dev/null; then
    do_interview=false

    if [[ "$INTERVIEW_MODE" == "true" ]]; then
        # Forced via --interview flag
        do_interview=true
    elif [[ "$INTERVIEW_MODE" == "false" ]]; then
        # Skipped via --no-interview flag
        do_interview=false
    else
        # Prompt user
        printf "Would you like me to ask clarifying questions first? [y/N] "
        read -r interview_reply
        if [[ "$interview_reply" =~ ^[Yy]$ ]]; then
            do_interview=true
        fi
        echo ""
    fi

    if [[ "$do_interview" == "true" ]]; then
        log "$RUN_ID" "MAIN" "Starting interview phase"
        set_run_state "$RUN_DIR" "interviewing"
        run_interview_phase "$RUN_ID" "$RUN_DIR" "$GOAL"
    fi
fi

# Step 3: Planning phase
log "$RUN_ID" "MAIN" "Starting planning phase"
set_run_state "$RUN_DIR" "planning"

if type run_planning_phase &>/dev/null; then
    run_planning_phase "$RUN_ID" "$RUN_DIR" "$GOAL"
else
    log_warn "Planner module not yet available. Create tasks manually in ${RUN_DIR}/tasks/"
    echo ""
    echo "The planner module is not yet built."
    echo "To continue development, manually create .spec files in:"
    echo "  ${RUN_DIR}/tasks/"
    echo ""
    echo "Run ID: ${RUN_ID}"
    exit 0
fi

# Step 4: Interactive review
if type run_review_phase &>/dev/null; then
    run_review_phase "$RUN_ID" "$RUN_DIR"
else
    # Fallback: show tasks and ask for approval
    display_all_tasks "$RUN_DIR"
    printf "Approve and execute? [y/N] "
    read -r reply
    if [[ ! "$reply" =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 0
    fi
fi

set_run_state "$RUN_DIR" "approved"
log "$RUN_ID" "MAIN" "Plan approved"

# Step 5: Dry run check
if [[ "$DRY_RUN" == "true" ]]; then
    echo ""
    log_info "Dry run mode. Skipping execution."
    display_all_tasks "$RUN_DIR"
    exit 0
fi

# Step 6: Execution phase
log "$RUN_ID" "MAIN" "Starting execution phase"
set_run_state "$RUN_DIR" "executing"

if type run_execution_phase &>/dev/null; then
    run_execution_phase "$RUN_ID" "$RUN_DIR"
else
    die "Execution module not yet available. Build Phase 4 first."
fi

# Step 7: Judging phase
log "$RUN_ID" "MAIN" "Starting judging phase"
set_run_state "$RUN_DIR" "judging"

if type run_judging_phase &>/dev/null; then
    run_judging_phase "$RUN_ID" "$RUN_DIR"
else
    log_warn "Judge module not yet available. Skipping evaluation."
    # Mark all done tasks as judged (pass by default)
    for task_id in $(list_tasks_by_status "$RUN_DIR" "done"); do
        echo "VERDICT=pass" > "${RUN_DIR}/tasks/${task_id}.judge"
    done
fi

# Step 7b: Retry failed tasks (if enabled)
if [[ "${SWARMTOOL_RETRY_ENABLED:-true}" == "true" ]]; then
    # Count failed tasks
    failed_count=0
    for judge_file in "$RUN_DIR"/tasks/*.judge; do
        [[ ! -f "$judge_file" ]] && continue
        verdict=$(grep "^VERDICT=" "$judge_file" 2>/dev/null | cut -d= -f2)
        [[ "$verdict" == "fail" ]] && ((failed_count++))
    done

    if [[ $failed_count -gt 0 ]]; then
        log "$RUN_ID" "MAIN" "Starting retry phase for $failed_count failed tasks"

        if type run_retry_phase &>/dev/null; then
            run_retry_phase "$RUN_ID" "$RUN_DIR"
        else
            log_warn "Retry module not available. Skipping retry phase."
        fi
    fi
fi

# Step 8: Merge phase
log "$RUN_ID" "MAIN" "Starting merge phase"
set_run_state "$RUN_DIR" "merging"

if type run_merge_phase &>/dev/null; then
    run_merge_phase "$RUN_ID" "$RUN_DIR"
else
    die "Merge module not yet available. Build Phase 6 first."
fi

# Step 9: Complete
set_run_state "$RUN_DIR" "complete"
log "$RUN_ID" "MAIN" "Run complete"

# Summary
echo ""

# Calculate stats for completion summary
pass_count=0
fail_count=0
total_count=0
for status_file in "${RUN_DIR}/tasks/"*.judge; do
    [[ -f "$status_file" ]] || continue
    ((total_count++))
    verdict=$(grep "^VERDICT=" "$status_file" 2>/dev/null | cut -d'=' -f2-)
    [[ "$verdict" == "pass" ]] && ((pass_count++))
    [[ "$verdict" == "fail" ]] && ((fail_count++))
done

# Calculate duration
start_time_str=$(get_run_meta "$RUN_DIR" "START_TIME")
if [[ -n "$start_time_str" ]]; then
    # Parse ISO timestamp to seconds (macOS/BSD compatible)
    if date -j -f "%Y-%m-%dT%H:%M:%SZ" "$start_time_str" +%s >/dev/null 2>&1; then
        start_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$start_time_str" +%s)
    else
        # GNU date fallback
        start_epoch=$(date -d "$start_time_str" +%s 2>/dev/null || echo 0)
    fi
    end_epoch=$(date +%s)
    duration=$((end_epoch - start_epoch))
else
    duration=0
fi

# Show fancy or simple completion
if type show_completion_summary &>/dev/null; then
    show_completion_summary "$RUN_ID" "$duration" "$pass_count" "$fail_count" "$total_count"
else
    print_header "Run Complete"
    display_progress "$RUN_DIR"
fi

echo ""
echo "Run ID: ${RUN_ID}"
echo "Logs:   ${RUN_DIR}/run.log"

# Cleanup
cleanup_run "$RUN_DIR"
